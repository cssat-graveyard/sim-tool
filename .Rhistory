#load the RODBC library
library(RODBC)
#loan nnet for multinom function
library(nnet)
#load glmnet to help with cross validation
library(glmnet)
#make pretty tables
library(pander)
#load lubridate to handle dates
library(lubridate)
#assign a connection object
cn <- odbcConnect("POC")
#use the connection object to send a query to our database
dat1 <- sqlQuery(cn,
"select
*
,id_prsn_child
from ps_tbl_parent_data tpd
join ps_tbl_children tc
on tpd.dcid=tc.dcid")
#count the number of parents
dat1_par <- length(unique(dat1$DCID))
dat1_par
#count the number of children
dat1_chi <- length(unique(dat1$id_prsn_child))
dat1_chi
dat2 <- sqlQuery(cn,
"with child_rem_id (dcid, id_prsn_child, id_removal_episode_fact)
as
(
select
tpd.dcid
,tc.id_prsn_child
,min(id_removal_episode_fact) id_removal_episode_fact
from
dbo.ps_tbl_parent_data tpd
join dbo.ps_tbl_children tc
on tpd.dcid=tc.dcid
join vw_episodes vep
on vep.eps_begin <= tpd.intdate
and vep.eps_begin >= dateadd(dd, -365, tpd.intdate)
and vep.id_prsn_child=tc.id_prsn_child
group by
tpd.dcid
,tc.id_prsn_child
)
select distinct
cri.id_prsn_child
,cri.id_removal_episode_fact
--check for records of dependency from AOC data
--for any dependency date that takes place after permanency, set date to null
,case
when datediff(dd
,isnull(vep.petition_dependency_date
,vep.eps_begin)
,isnull(vep.earlier_of_eps_end_18th_bday
,'2013-12-31')) < 0
then null
else vep.petition_dependency_date
end dep_date
--calculate the timing of court involvement
,case
--check for petitions before removal and set time to 0
when
datediff(dd
,vep.eps_begin
,isnull(vep.petition_dependency_date
,vep.eps_begin)) < 0
then
0
--treat missing dependency dates (from logic above) with dur_days
--greater than 365 as immediate dependencies
when
case
when datediff(dd
,isnull(vep.petition_dependency_date
,vep.eps_begin)
,isnull(vep.earlier_of_eps_end_18th_bday
,'2013-12-31')) < 0
then null
else vep.petition_dependency_date
end is null
and
dur_days > 365
then
0
--treat missing dependency dates with dur_days less than 365 as VPA cases
when
case
when datediff(dd
,isnull(vep.petition_dependency_date
,vep.eps_begin)
,isnull(vep.earlier_of_eps_end_18th_bday
,'2013-12-31')) < 0
then null
else vep.petition_dependency_date
end is null
then
dur_days
--check for petitions after permanency and set time to episode duration
when
datediff(dd
,vep.petition_dependency_date
,isnull(vep.earlier_of_eps_end_18th_bday
,'2013-12-31')) < 0
then
dur_days
--for all other cases just calculate the time from
--eps_begin to the AOC petition
else
datediff(dd
,vep.eps_begin
,isnull(vep.petition_dependency_date
,vep.eps_begin))
end crt_t
,case
--check for petitions before removal and flag as court involvement
when
datediff(dd
,vep.eps_begin
,isnull(vep.petition_dependency_date
,vep.eps_begin)) < 0
then
1
--treat missing dependency dates (from logic above) with
--dur_days greater than 365 as immediate dependencies
when
case
when datediff(dd
,isnull(vep.petition_dependency_date
,vep.eps_begin)
,isnull(vep.earlier_of_eps_end_18th_bday
,'2013-12-31')) < 0
then null
else vep.petition_dependency_date
end is null
and
dur_days > 365
then
1
--treat missing dependency dates with dur_days less than 365 as VPA cases
when
case
when datediff(dd
,vep.petition_dependency_date
,isnull(vep.earlier_of_eps_end_18th_bday
,'2013-12-31')) < 0
then null
else vep.petition_dependency_date
end is null
then
0
--check for petitions after permanency and set time to episode duration
--(effectively VPAs)
when
datediff(dd
,vep.petition_dependency_date
,isnull(vep.earlier_of_eps_end_18th_bday
,'2013-12-31')) < 0
then
0
--for all other cases just calculate the time from eps_begin to the
--AOC or CA petition
else
1
end crt_s
,dur_days reu_t
,case
when outcome = 'Reunification' then 1 else 0
end reu_s
,dur_days adt_t
,case
when outcome = 'Adoption' then 1 else 0
end adt_s
,dur_days gdn_t
,case
when outcome = 'Guardianship' then 1 else 0
end gdn_s
,datediff(dd, vep.eps_begin, tpd.intdate) time_to_int
,tpd.*
,vep.*
from
dbo.ps_tbl_parent_data tpd
join child_rem_id cri
on tpd.dcid=cri.dcid
join vw_episodes vep
on vep.id_removal_episode_fact = cri.id_removal_episode_fact
order by vep.id_removal_episode_fact")
#count the number of parents
dat2_par <- length(unique(dat2$DCID))
dat2_par
#count the number of children
dat2_chi <- length(unique(dat2$id_prsn_child))
dat2_chi
pander(table(factor(dat2$crt_s,levels=c(0,1),labels=c("No Court", "Court")), dnn="Count"))
pander(table(dat2$outcome, dnn="Count"), split.table = Inf)
dat3 <- subset(dat2, !(dat2$outcome %in% c("Still in Care", "Other")) & dat2$crt_s == 1)
#count the number of parents
dat3_par <- length(unique(dat3$DCID))
dat3_par
#count the number of children
dat3_chi <- length(unique(dat3$id_prsn_child))
dat3_chi
#define factor based outcome with reunification as reference category
dat3$outcome <- as.factor(as.character(dat3$outcome))
levels(dat3$outcome) <- c("Adoption", "Emancipation", "Guardianship", "Reunification")
dat3$outcome <- relevel(dat3$outcome, ref = "Reunification")
#prep covariates
#log transform age at episode begin
dat3$log_age_eps_begin <- log1p(dat3$age_eps_begin)
#flag for adolescent child
dat3$ad_chld <- ifelse(dat3$age_eps_begin > 11, 1, 0)
#flag for toddler
dat3$sm_chld <- ifelse(dat3$age_eps_begin <= 3, 1, 0)
#flag for white
dat3$non_min <- ifelse(dat3$cd_race_census == 5, 1, 0)
#flag for male
dat3$male <- ifelse(dat3$cd_gndr == "M", 1, 0)
#flag for parent age
dat3$par_age <- year(strptime(dat3$eps_begin, format = "%Y-%m-%d"))-year(strptime(dat3$DOB, format = "%Y-%m-%d"))
#flag for log transformed parent age
dat3$log_par_age <- log(dat3$par_age)
#flag for marriage status
dat3$married <- ifelse(dat3$MARSTAT < 1, NA, ifelse(dat3$MARSTAT == 2, 1, 0))
#count of Number of biological or adopted children
dat3$hhnum_c <- ifelse(dat3$CHTOTNUM < 1, NA, dat3$CHTOTNUM)
#flag for longest placement in relative setting
dat3$rel_plc <- ifelse(as.numeric(dat3$longest_plcm_setng)==3,1,0)
#sequence of placement episode
dat3$eps_rank <- dat3$eps_rank
#log transform of sequence of placement episode
dat3$log_eps_rank <- log(dat3$eps_rank)
#total housing hardship count
dat3$housing_hs_cnt <- ifelse(is.na(dat3$LACRENT) == TRUE | dat3$LACRENT == 2, 0, 1) +
ifelse(is.na(dat3$EVICT) == TRUE | dat3$EVICT == 2, 0, 1) +
ifelse(is.na(dat3$FAMFRND) == TRUE | dat3$FAMFRND == 2, 0, 1) +
ifelse(is.na(dat3$REPOSS) == TRUE | dat3$REPOSS == 2, 0, 1) +
ifelse(is.na(dat3$HOMLSS) == TRUE | dat3$HOMLSS == 2, 0, 1)
#flag for housing hardship
dat3$hsg_hds <- ifelse(dat3$housing_hs_cnt > 0, 1, 0)
#flag for income over 10,000K
dat3$high_in <- ifelse(dat3$THHINC < 1, NA, ifelse(dat3$THHINC > 1, 1, 0))
#flag for more than high school
dat3$sm_coll <- ifelse(dat3$EDULVL < 1, NA, ifelse(dat3$EDULVL > 3, 1, 0))
#flag for full or part time employment
dat3$employ <- ifelse(dat3$EMPSTAT < 1, NA, ifelse(dat3$EMPSTAT != 1, 1, 0))
#engagement recoding
#first step is to recode responses to likert or NA only (dont know or refuse are all NA)
#receptivity
dat3$y2 = ifelse(dat3$YENG2 < 1, NA, dat3$YENG2)
dat3$y3 = ifelse(dat3$YENG3 < 1, NA, dat3$YENG3)
dat3$y7 = ifelse(dat3$YENG7 < 1, NA, dat3$YENG7)
dat3$y15 = ifelse(dat3$YENG15 < 1, NA, dat3$YENG15)
#working relationship
dat3$y5 = ifelse(dat3$YENG5 < 1, NA, dat3$YENG5)
dat3$y9 = ifelse(dat3$YENG9 < 1, NA, dat3$YENG9)
dat3$y11 = ifelse(dat3$YENG11 < 1, NA, dat3$YENG11)
dat3$y16 = ifelse(dat3$YENG16 < 1, NA, dat3$YENG16)
#mistrust
dat3$y6 = ifelse(dat3$YENG6 < 1, NA, dat3$YENG6)
dat3$y12 = ifelse(dat3$YENG12 < 1, NA, dat3$YENG12)
dat3$y18 = ifelse(dat3$YENG18 < 1, NA, dat3$YENG18)
#buyin
dat3$y1 = ifelse(dat3$YENG1 < 1, NA, dat3$YENG1)
dat3$y4 = ifelse(dat3$YENG4 < 1, NA, dat3$YENG4)
dat3$y8 = ifelse(dat3$YENG8 < 1, NA, dat3$YENG8)
dat3$y10 = ifelse(dat3$YENG10 < 1, NA, dat3$YENG10)
dat3$y13 = ifelse(dat3$YENG13 < 1, NA, dat3$YENG13)
dat3$y14 = ifelse(dat3$YENG14 < 1, NA, dat3$YENG14)
dat3$y17 = ifelse(dat3$YENG17 < 1, NA, dat3$YENG17)
dat3$y19 = ifelse(dat3$YENG19 < 1, NA, dat3$YENG19)
#next step is to calculate factor scores on the basis of the hypothetical factor structure of Yatchmenoff, 2005
#note that indices are hard coded. if columns are added prior to this beyond those already coded, we will need to update the column indices accordingly
#calculate factor scores
library(psych)
dat_recep <- dat3[,c(345:348)]
dat_recep_scores <- fa.poly(dat_recep)
dat3$recep_scores <- as.numeric(dat_recep_scores$scores$scores)
dat_wrkg <- dat3[,c(349:352)]
dat_wrkg_scores <- fa.poly(dat_wrkg)
dat3$wrkg_scores <- as.numeric(dat_wrkg_scores$scores$scores)
dat_mist <- dat3[,c(353:355)]
dat_mist_scores <- fa.poly(dat_mist)
dat3$mist_scores <- as.numeric(dat_mist_scores$scores$scores)
dat_buyn <- dat3[,c(356:363)]
dat_buyn_scores <- fa.poly(dat_buyn)
dat3$buyn_scores <- as.numeric(dat_buyn_scores$scores$scores)
#next step is to make centered transformations of all of the engagement items. Again, note the index problem...
#transform our variables
#linear
library(stringr)
var_tx_lin <- dat3[,c(345:363)] - 3
nam <- names(var_tx_lin)
names(var_tx_lin) <- str_c(nam, '_lin')
#signed square transform
var_tx_sgnsq <- sign(var_tx_lin) * abs(var_tx_lin)^2
names(var_tx_sgnsq) <- str_c(nam, '_signsq')
#signed square root transform
var_tx_sgnsqrt <- sign(var_tx_lin) * sqrt(abs(var_tx_lin))
names(var_tx_sgnsqrt) <- str_c(nam, '_signsqrt')
#ternary transform
var_tx_tern <- lapply(dat3[,c(345:363)]
,function(x) as.numeric(as.character(cut(x
,breaks = c(0,2,3,5)
,labels=c(-1,0,1)
)))
)
var_tx_tern <- as.data.frame(var_tx_tern)
names(var_tx_tern) <- str_c(nam, '_tern')
#code each variable as a factor as well
#receptivity
dat3$y2_fac = as.factor(ifelse(dat3$YENG2 < 1, NA, dat3$YENG2))
dat3$y3_fac = as.factor(ifelse(dat3$YENG3 < 1, NA, dat3$YENG3))
dat3$y7_fac = as.factor(ifelse(dat3$YENG7 < 1, NA, dat3$YENG7))
dat3$y15_fac = as.factor(ifelse(dat3$YENG15 < 1, NA, dat3$YENG15))
#working relationship
dat3$y5_fac = as.factor(ifelse(dat3$YENG5 < 1, NA, dat3$YENG5))
dat3$y9_fac = as.factor(ifelse(dat3$YENG9 < 1, NA, dat3$YENG9))
dat3$y11_fac = as.factor(ifelse(dat3$YENG11 < 1, NA, dat3$YENG11))
dat3$y16_fac = as.factor(ifelse(dat3$YENG16 < 1, NA, dat3$YENG16))
#mistrust
dat3$y6_fac = as.factor(ifelse(dat3$YENG6 < 1, NA, dat3$YENG6))
dat3$y12_fac = as.factor(ifelse(dat3$YENG12 < 1, NA, dat3$YENG12))
dat3$y19_fac = as.factor(ifelse(dat3$YENG19 < 1, NA, dat3$YENG19))
#buyin
dat3$y1_fac = as.factor(ifelse(dat3$YENG1 < 1, NA, dat3$YENG1))
dat3$y4_fac = as.factor(ifelse(dat3$YENG4 < 1, NA, dat3$YENG4))
dat3$y8_fac = as.factor(ifelse(dat3$YENG8 < 1, NA, dat3$YENG8))
dat3$y10_fac = as.factor(ifelse(dat3$YENG10 < 1, NA, dat3$YENG10))
dat3$y13_fac = as.factor(ifelse(dat3$YENG13 < 1, NA, dat3$YENG13))
dat3$y14_fac = as.factor(ifelse(dat3$YENG14 < 1, NA, dat3$YENG14))
dat3$y17_fac = as.factor(ifelse(dat3$YENG17 < 1, NA, dat3$YENG17))
dat3$y19_fac = as.factor(ifelse(dat3$YENG19 < 1, NA, dat3$YENG19))
#relevel county
dat3$county <- relevel(dat3$county, ref = "King")
#some additional vars
#dat3$los_at_int <- as.numeric(difftime(dat3$INTDATE, dat3$eps_begin, units = "days"))
#some additional vars
#dat3$los <- as.numeric(difftime(dat3$eps_end, dat3$eps_begin, units = "days"))
#here we subset our data to the chosen covariates in the model
dat4 <- dat3[,c("outcome"
,"mist_scores"
,"wrkg_scores"
,"recep_scores"
,"buyn_scores"
,"log_age_eps_begin"
,"non_min"
,"male"
,"par_age"
,"log_par_age"
,"married"
,"hhnum_c"
,"rel_plc"
,"eps_rank"
,"log_eps_rank"
,"housing_hs_cnt"
,"hsg_hds"
,"high_in"
,"sm_coll"
,"employ"
,"county"
)]
# run the multinomial model
model <- multinom(outcome ~ .
,data = dat4
,Hess = TRUE)
summary(model)
library(rmarkdown)
library(knitr)
unique(dat4$county)
dat4
dat4 <- dat3[,c("outcome"
,"mist_scores"
,"wrkg_scores"
,"recep_scores"
,"buyn_scores"
,"log_age_eps_begin"
,"non_min"
,"male"
,"par_age"
,"log_par_age"
,"married"
,"hhnum_c"
,"rel_plc"
,"eps_rank"
,"log_eps_rank"
,"housing_hs_cnt"
,"hsg_hds"
,"high_in"
,"sm_coll"
,"employ"
,"county"
)]
